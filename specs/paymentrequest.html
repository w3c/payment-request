<!DOCTYPE html>
<html>
  <head>
    <title>Payment Request API</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          shortName:  "payment-request",
          edDraftURI:   "https://w3c.github.io/browser-payment-api/paymentrequest.html",

          specStatus: "ED",
          editors: [
                {   name:       "Adrian Bateman",
                    company:    "Microsoft Corporation" },
                {   name:       "Zach Koch",
                    company:    "Google" },
                {   name:       "Richard Barnes",
                    company:    "Mozilla Foundation" },
                {   name:       "Roy McElmurry",
                    company:    "Facebook" },
          ],

          useExperimentalStyles: true,
          license:      "w3c-software-doc",

          //previousMaturity: "FPWD",
          //previousPublishDate:  "1977-03-15",

          wg:           "Web Payments Working Group",
          wgURI:        "https://www.w3.org/Payments/WG/",
          wgPublicList: "public-payments-wg",
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83744/status",

          issueBase:    "https://github.com/w3c/browser-payment-api/issues/",

          localBiblio:  {
              "PAYMENTARCH": {
                  title:    "Payment Request Architecture"
              ,   href:     "architecture.html"
              ,   authors:  [
                      "Adrian Bateman"
                  ,   "Zach Koch"
                  ,   "Richard Barnes"
                  ]
              ,   status:   "ED"
              },
              "METHODIDENTIFIERS": {
                  title:    "Payment Method Identifiers"
              ,   href:     "method-identifiers.html"
              ,   authors:  [
                      "Adrian Bateman"
                  ,   "Zach Koch"
                  ,   "Richard Barnes"
                  ]
              ,   status:   "ED"
              }
          }
      };
    </script>
    <style>
    dt { margin-top: 0.75em; }
    table { margin-top: 0.75em; border-collapse:collapse; border-style:hidden hidden none hidden }
    table thead { border-bottom:solid }
    table tbody th:first-child { border-left:solid }
    table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
    li { margin-top: 0.5em; margin-bottom: 0.5em;}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification describes a web API to allow merchants (i.e. web sites selling
        physical or digital goods) to easily accept payments from different payment methods with
        minimal integration. User agents (e.g. browsers) will facilitate the payment flow between
        merchant and user.
      </p>
    </section>

    <section id='sotd'>
      <p>
        The working group maintains <a href="https://github.com/w3c/browser-payment-api/issues">a
        list of all bug reports that the group has not yet addressed</a>.
        This draft highlights some of the pending issues that are still to be discussed in the working
        group. No decision has been taken on the outcome of these issues including whether they are valid.
        Pull requests with proposed specification text for outstanding issues are strongly encouraged.
      </p>
      <p>
        This specification was derived from a report published previously by the
        <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>.
      </p>
    </section>

    <section class='informative'>
      <h2>Introduction</h2>
        <p>Buying things on the
        web, particularly on mobile, can be a frustrating experience for users. Every web site has its own flow
        and its own validation rules, and most require users to manually type in the same set of information
        over and over again. Likewise, it is difficult and time consuming for developers to create good
        checkout flows that support various payment schemes.</p>

        <p>This specification describes an API that allows <a>user agents</a> (e.g. browsers) to act
        as an intermediary between the three key parties in every transaction: the merchant (e.g. an
        online web store), the buyer (e.g. the user buying from the online web store), and the
        <a>Payment Method</a> (e.g. credit card). Information necessary to process and confirm a
        transaction is passed between the <a>Payment Method</a> and the merchant via the <a>user agent</a>
        with the buyer confirming and authorizing as necessary across the flow.</p>

        <p>In addition to better, more consistent user experiences, this also enables web sites to take
        advantage of more secure payment schemes (e.g. tokenization and system-level authentication)
        that are not possible with standard JavaScript libraries. This has the potential to reduce
        liability for the merchant and helps protect sensitive user information.</p>

        <p>The API described in this document forms part of the Payment Request system described in
        the Payment Request Architecture [[PAYMENTARCH]] document.</p>

      <section id="goals">
        <h2>Goals</h2>
        <ul>
          <li>Allow the user agent to act as intermediary between merchants, users, and <a>payment
          methods</a></li>
          <li>Standardize (to the extent that it makes sense) the communication flow between a
          merchant, user agent, and <a>payment method</a></li>
          <li>Allow <a>payment methods</a> to bring more secure payment transactions to the web</li>
        </ul>
      </section>

      <section id="non-goals">
        <h2>Non-goals</h2>
          <ul>
            <li>Not trying to create a new <a>payment method</a></li>
            <li>Not trying to integrate directly with payment processors</li>
          </ul>
      </section>

    </section>

    <section id='conformance'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
      <dt><dfn>Conforming user agent</dfn></dt>
      <dd>
        <p>
        A <dfn data-lt="user agents">user agent</dfn> MUST behave as described in this specification
        in order to be considered conformant. In this specification, <a>user agent</a> means a <em>Web
        browser or other interactive user agent</em> as defined in [[!HTML5]].
        </p>
        <p>
        User agents MAY implement algorithms given in this
        specification in any way desired, so long as the end result is
        indistinguishable from the result that would be obtained by the
        specification's algorithms.
        </p>
        <p>
        A conforming Payment Request API user agent MUST also be a
        <em>conforming implementation</em> of the IDL fragments
        of this specification, as described in the
        “Web IDL” specification. [[!WEBIDL]]
        </p>

        <aside class="note">
        This specification uses both the terms "conforming user agent(s)"
        and "user agent(s)" to refer to this product class.
        </aside>
      </dd>
      </dl>
    </section>

    <section id="dependencies">
      <h2>Dependencies</h2>
      <p>
      This specification relies on several other underlying specifications.
      </p>
      <dl>
        <dt>Payment Request Architecture</dt>
        <dd>The terms <dfn data-lt="payment method|payment methods">Payment Method</dfn>,
        <dfn data-lt="payment app|payment apps">Payment App</dfn>, and <dfn>Payment Transaction
        Message Specification</dfn> are defined by the Payment Request Architecture document
        [[PAYMENTARCH]].</dd>
        <dt>Payment Method Identifiers</dt>
        <dd>The term <dfn data-lt="payment method identifier|payment method identifiers">Payment
        Method Identifier</dfn> is defined by the Payment Method Identifiers specification
        [[!METHODIDENTIFIERS]].</dd>
        <dt>HTML5</dt>
        <dd>The terms <dfn>global object</dfn>,
        <dfn>queue a task</dfn>, <dfn>browsing context</dfn>, and
        <dfn>top-level browsing context</dfn> are defined by [[!HTML5]].</dd>
        <dt>ECMA-262 6th Edition, The ECMAScript 2015 Language Specification</dt>
        <dd>
          The terms <dfn>Promise</dfn>, <dfn>internal slot</dfn>, <dfn><code>TypeError</code></dfn>, <dfn>JSON.stringify</dfn>, and <dfn>JSON.parse</dfn> are
          defined by [[!ECMA-262-2015]].
          <p>This document uses the format <em>object</em>@[[\slotname]] to mean the internal slot [[\slotname]]
          of the object <em>object</em>.</p>
          <p>The term <dfn>JSON-serializable object</dfn> used in this specification means an object that can
          be serialized to a string using <a>JSON.stringify</a> and later deserialized back to an object
          using <a>JSON.parse</a> with no loss of data.</p>
        </dd>
        <dt>DOM4</dt>
        <dd>
        The <code><dfn>Event</dfn></code> type and the terms <dfn>fire an event</dfn>, <dfn>dispatch flag</dfn>,
        <dfn>stop propagation flag</dfn>, and <dfn>stop immediate propagation flag</dfn> are defined by [[!DOM4]].
        <p><dfn>DOMException</dfn> and the following DOMException types from [[!DOM4]] are used:</p>
        <table>
        <tr><th>Type</th><th>Message (optional)</th></tr>
        <tr><td><code><dfn>InvalidStateError</dfn></code></td><td>The object is in an invalid state</td></tr>
        <tr><td><code><dfn>NotSupportedError</dfn></code></td><td>The payment method was not supported</td></tr>
        <tr><td><code><dfn>SecurityError</dfn></code></td><td>The operation is only supported in a secure context</td></tr>
        </table>
        </dd>
        <dt>WebIDL</dt>
        <dd>When this specification says to <dfn>throw</dfn> an error, the <a>user agent</a> must throw an
        error as described in [[!WEBIDL]]. When this occurs in a sub-algorithm, this results in
        termination of execution of the sub-algorithm and all ancestor algorithms until one is
        reached that explicitly describes procedures for catching exceptions.</dd>
        <dt>Secure Contexts</dt>
        <dd>The term <dfn>secure context</dfn> is defined by the Secure Contexts specification
        [[!POWERFUL-FEATURES]].</dd>
      </dl>
    </section>

    <section>
      <h2>PaymentRequest interface</h2>
      <pre class="idl">
        [Constructor(sequence&lt;DOMString&gt; supportedMethods, PaymentDetails details, optional PaymentOptions options, optional object data)]
        interface PaymentRequest : EventTarget {
          Promise&lt;PaymentResponse&gt; show();
          void abort();

          readonly attribute ShippingAddress? shippingAddress;
          readonly attribute DOMString? shippingOption;

          /* Supports "shippingaddresschange" event */
          attribute EventHandler onshippingaddresschange;

          /* Supports "shippingoptionchange" event */
          attribute EventHandler onshippingoptionchange;
        };
      </pre>

      <p>
        A web page creates a <a><code>PaymentRequest</code></a> to make a payment request. This is
        typically associated with the user initiating a payment process 
        (e.g., selecting a "Power Up" in an interactive game, pulling up to an automated kiosk in a parking structure,
        or activating a "Buy", "Purchase", or "Checkout" button).
        The <a><code>PaymentRequest</code></a> allows the web page to exchange information with the
        <a>user agent</a> while the user is providing input before approving or denying a payment request.
      </p>

      <p>The following example shows how to construct a <a><code>PaymentRequest</code></a> and begin the
      user interaction:</p>

      <pre class="example highlight">
        var payment = new PaymentRequest(supportedMethods, details, options, data);
        payment.addEventListener("shippingaddresschange", function (changeEvent) {
            // Process shipping address change
        });

        payment.show().then(function(paymentResponse) {
          // Process paymentResponse
          // paymentResponse.methodName contains the selected payment method
          // paymentResponse.details contains a payment method specific response
          paymentResponse.complete(true);
        }).catch(function(err) {
          console.error("Uh oh, something bad happened", err.message);
        });
      </pre>

      <section>
        <h2>PaymentRequest constructor</h2>
        <p>
          The <a><code>PaymentRequest</code></a> is constructed using the supplied <code>supportedMethods</code>
          list, the payment <code>details</code>, the payment <code>options</code>, and any <a>payment
          method</a> specific <code>data</code>.
        </p>
        <div class="issue" data-number="40" title="How does a website pass additional (not payment method specific) data to the payment app?">
          It is proposed that a conformance criteria for implementations of this API be 
          that any data passed into the request is passed on to the payment app unaltered. 
          This would allow extensions of the data schema such as the addition of 
          properties that are not documented in this specification or known to implementors 
          such as JSON-LD @context or similar to be passed between the website and 
          payment app.
        </div>
        <div class="note">
          <p>The <code>supportedMethods</code> sequence contains the <a>payment method identifiers</a>
          for the <a>payment methods</a> that the merchant web site accepts.</p>
          <pre class="example highlight">
            ["visa", "bitcoin", "bobpay.com"]
          </pre>

          <p>The <code>details</code> object contains information about the transaction that the
          user is being asked to complete such as the line items in an order.</p>
          <pre class="example highlight">
            {
              "items": [
                {
                  "id": "basket",
                  "label": "Sub-total",
                  "amount": { "currency": "USD", "value" : "55.00" }, // US$55.00
                },
                {
                  "id": "tax",
                  "label": "Sales Tax",
                  "amount": { "currency": "USD", "value" : "5.00" }, // US$5.00
                },
                {
                  "id": "total",
                  "label": "Total due",
                  "amount": { "currency": "USD", "value" : "60.00" }, // US$60.00
                }
              ]
            }
          </pre>

          <p>The <code>options</code> object contains information about what options the web page
          wishes to use from the payment request system.</p>

          <pre class="example highlight">
            {
              "requestShipping": true
            }
          </pre>

          <p><code>data</code> is a <a>JSON-serializable object</a> that provides optional information that might
          be needed by the supported <a>payment methods</a>.</p>
          <pre class="example highlight">
            {
              "bobpay.com": {
                  "merchantIdentifier": "XXXX",
                  "bobPaySpecificField": true
              },
              "bitcoin": {
                  "address": "XXXX"
              }
            }
          </pre>
        </div>

        <div class="issue" data-number="15" title="Combine API parameters into a single request object + options">
          There is an open issue about whether <code>supportedMethods</code>, <code>details</code>, and <code>data</code>
          should be combined into a single object.
        </div>

        <div class="issue" data-number="16" title="Use navigator.payments singleton, factory method, or PaymentRequest constructor">
          There is an open issue about how a payment request is initiated. The options proposed include using a singleton
          at <code>navigator.payments</code>, using a factory method to create an instance, or using a constructor as
          currently described in the specification.
        </div>

        <div class="issue" data-number="47" title="Should a payment request be just data, or a programmable object?">
          There is an open issue about whether the payment request should
          be a programmable object or should be just pure data that can be
          operated on by methods.
        </div>

        <div class="issue" data-number="19" title="Should the API handle pre-auth, recurring payments, and similar scenarios">
          There is an open issue about whether the API should handle occasions when a site wants to request a payment
          method but not actually make a charge immediately. These may include identification validation, pre-auth
          for a deposit, pre-auth for a later payment, making recurring payments, and more.
        </div>

        <div class="issue" data-number="23" title="Can the merchant influence order of presentation of payment apps to the user">
          There is an open issue about whether the merchant can influence order of presentation of
          payment apps to the user. There is a suggestion that we should support merchants specifying
          a preference and allow users to express a preference that overrides merchant preferences.
        </div>

        <div class="issue" data-number="48" title="Should list of accepted payment methods be strings or objects?">
          There is an open issue about whether the list of supported payment
          methods should be passed to the user agent as a simple sequence of
          strings or as a more complex and flexible object structure.
        </div>

        <div class="issue" data-number="51" title="Should the payment API be more conversational or less conversational?">
          There is an open issue regarding whether the current pattern of using
          events for exchange of data between the user agent and the website is
          the best design for this API. An alternative pattern has been
          proposed in the issue thread.
        </div>

        <p>
          The <a><code>PaymentRequest</code></a> constructor MUST act as follows:
        </p>
        <ol>
          <li>
            If the length of the <code>supportedMethods</code> sequence is zero, then <a>throw</a>
            a <a><code>TypeError</code></a>.
          </li>
          <li>
            If the <a>global object</a> of the script calling the constructor is
            not considered a <a>secure context</a>, then <a>throw</a> a <a><code>SecurityError</code></a>.
            <div class="issue" data-number="22" title="Spec should use [SecureContext] once that is defined in Web IDL">
              Using [SecureContext] in Web IDL will allow us to eliminate this prose.
            </div>
          </li>
          <li>
            If the <a>browsing context</a> of the script calling the constructor is
            not a <a>top-level browsing context</a>, then <a>throw</a> a <a><code>SecurityError</code></a>.
            <div class="issue" data-number="2"
                title="Should the Payment Request API only be available in a top-level browsing context? ">
              <p>There is an open issue about requiring
              a top-level browsing context for using <code>PaymentRequest</code>. Requiring one
              is a mitigation for a user being tricked into thinking a trusted site is asking for
              payment when in fact an untrusted iframe is asking for payment. The problem is some iframes may
              have a legitimate reason to request payment.</p>
            </div>
          </li>
          <li>
            If <code>details</code> does not contain a sequence of <code>items</code> with length greater
            than zero, then <a>throw</a> a <a><code>TypeError</code></a>.
          </li>
          <li>
            If <code>data</code> is not a <a>JSON-serializable object</a>, then <a>throw</a> a <a><code>TypeError</code></a>.
          </li>
          <li>
            If the name of any top level field of <code>data</code> does not match one of the <a>payment method identifiers</a>
            in <code>supportedMethods</code>, then <a>throw</a> a <a><code>TypeError</code></a>.
          </li>
          <li>
            If the value of any top level field is not a <a>JSON-serializable object</a>, then
            <a>throw</a> a <a><code>TypeError</code></a>.
          </li>
          <li>Let <em>request</em> be a new <a><code>PaymentRequest</code></a>.</li>
          <li>Store <code>supportedMethods</code> into <em>request</em>@[[\supportedMethods]].</li>
          <li>Store <code>details</code> into <em>request</em>@[[\details]].</li>
          <li>Store <code>options</code> into <em>request</em>@[[\options]].</li>
          <li>Store <code>data</code> into <em>request</em>@[[\data]].</li>
          <li>Set the value <em>request</em>@[[\state]] to <em>created</em>.</li>
          <li>
            Set the value of the <a><code>shippingAddress</code></a> attribute on <em>request</em> to <em>null</em>.
          </li>
          <li>
            Set the value of the <a><code>shippingOption</code></a> attribute on <em>request</em> to <em>null</em>.
          </li>
          <li>
            If <code>details</code> contains a <code>shippingOptions</code> sequence with a
            length of 1, then set <a><code>shippingOption</code></a> to the <code>id</code> of
            the only <a><code>ShippingOption</code></a> in the sequence.
          </li>
          <li>Set the value <em>request</em>@[[\updating]] to <em>false</em>.</li>
          <li>Return <em>request</em>.</li>
        </ol>
      </section>

      <section>
        <h2>show()</h2>
        <p>
          The <code><dfn>show</dfn></code> method is called when the page wants to begin user interaction for the
          payment request. The <code>show</code> method will return a <a>Promise</a> that will be resolved when the
          <a>user accepts the payment request</a>. Some kind of user interface will be presented to the user to facilitate the
          payment request after the <code>show</code> method returns.
        </p>

        <p class="issue" data-number="56" title="Should a website be able to provide a label for the 'Buy' or 'Checkout' button displayed in the payment app?">
          It may help users understand what they are accepting if the web site
          is able to label the "accept" button. For example, if a user is about
          to "Buy" something, "Reserve" something, "Subscribe" to something,
          etc. That said, this may create payment interface/experience issues
          and accidentally lead to customers thinking they're performing
          actions like a one-time purchase, when they are in fact signing up
          for a subscription.
        </p>
        <p>
          The <a><code>show</code></a> method MUST act as follows:
        </p>
        <ol>
          <li>
            Let <em>request</em> be the <a><code>PaymentRequest</code></a> object on which the method is called..
          </li>
          <li>If the value of <em>request</em>@[[\state]] is not <em>created</em> then
          <a>throw</a> an <a><code>InvalidStateError</code></a>.</li>
          <li>
            Set the value of <em>request</em>@[[\state]] to <em>interactive</em>.
          </li>
          <li>
            Let <em>acceptPromise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Store <em>acceptPromise</em> in <em>request</em>@[[\acceptPromise]].
          </li>
          <li>
            Return <em>acceptPromise</em> and asynchronously perform the remaining steps.
          </li>
          <li>
            Let <em>acceptedMethods</em> be the sequence of payment method identifiers <em>request</em>@[[\supportedMethods]]
            with all identifiers removed that the <a>user agent</a> does not accept.
          </li>
          <li>
            If the length of <em>acceptedMethods</em> is zero, then reject <em>acceptPromise</em> with a <a><code>NotSupportedError</code></a>.
          </li>
          <li>
            Show a user interface to allow the user to interact with the payment request process. The <em>acceptPromise</em> will
            later be resolved by the <a>user accepts the payment request algorithm</a> through interaction with the user interface.
          </li>
        </ol>
      </section>

      <section>
        <h2>abort()</h2>
        <p>The <code><dfn>abort</dfn></code> method may be called if the web page wishes to abort the payment
        request after the <a><code>show</code></a> method has been called and before the [[\acceptPromise]]
        has been resolved.</p>

        <p>The <a><code>abort</code></a> method MUST act as follows:</p>
        <ol>
          <li>If the value of [[\state]] is not <em>interactive</em> then
          <a>throw</a> an <a><code>InvalidStateError</code></a>.</li>
          <li>Set the value of the internal slot [[\state]] to <em>closed</em>.</li>
          <li>Return from the method and asynchronously perform the remaining steps.</li>
          <li>Abort the current user interaction and close down any remaining user interface</li>
        </ol>
      </section>

      <section>
        <h2 id="state-transitions" class="informative">State transitions</h2>
          <p>The internal slot [[\state]] follows the following state transitions:</p>
          <img alt="Transition diagram for internal slot state of a PaymentRequest object" 
               src="state-transitions.svg" width="608" height="235">
      </section>

      <section>
        <h2>shippingAddress</h2>
        <p>
          <code>shippingAddress</code> is populated when the user provides a shipping
          address. It is <em>null</em> by default.
          When a user provides a shipping address, the <a>shipping address changed algorithm</a> runs.
        </p>
        <p>
          <code><dfn>onshippingaddresschange</dfn></code> is an <code>EventHandler</code> for an
          <code>Event</code> named <code>shippingaddresschange</code>.
        </p>
      </section>

      <section>
        <h2>shippingOption</h2>
        <p>
          <code>shippingOption</code> is populated when the user chooses a shipping
          option. It is <em>null</em> by default.
          When a user chooses a shipping option, the <a>shipping option changed algorithm</a> runs.
        </p>
        <p>
          <code><dfn>onshippingoptionchange</dfn></code> is an <code>EventHandler</code> for an
          <code>Event</code> named <code>shippingoptionchange</code>.
        </p>
      </section>

      <section>
        <h2>Internal Slots</h2>
        <p>Instances of <a><code>PaymentRequest</code></a> are created with the internal slots in
        the following table:</p>
        <table>
          <tr><th>Internal Slot</th><th>Description (<em>non-normative</em>)</th></tr>
          <tr>
            <td>[[\supportedMethods]]</td>
            <td>The <code>supportMethods</code> supplied to the constructor.</td>
          </tr>
          <tr>
            <td>[[\details]]</td>
            <td>
              The current <a><code>PaymentDetails</code></a> for the payment request initially
              supplied to the constructor and then updated with calls to <a><code>updateWith</code></a>.
            </td>
          </tr>
          <tr>
            <td>[[\options]]</td>
            <td>The <a><code>PaymentOptions</code></a> supplied to the constructor.</td>
          </tr>
          <tr>
            <td>[[\data]]</td>
            <td>
              The payment method specific <code>data</code> supplied to the constructor used
              by a <a>Payment App</a> to influence the app's behavior.
            </td>
          </tr>
          <tr>
            <td>[[\state]]</td>
            <td>The current <a class="internalDFN" href="#state-transitions">state</a> of the payment request.</td>
          </tr>
          <tr>
            <td>[[\updating]]</td>
            <td>
               <em>true</em> is there is a pending <a><code>updateWith</code></a> call to update
               the payment request and <em>false</em> otherwise.
            </td>
          </tr>
          <tr>
            <td>[[\acceptPromise]]</td>
            <td>
              The pending <a>Promise</a> created during <a><code>show</code></a> that will be
              resolved if the user accepts the payment request.
            </td>
          </tr>
        </table>
      </section>

    </section>

    <section>
      <h2>CurrencyAmount</h2>
      <pre class="idl">
dictionary CurrencyAmount {
  required DOMString currency;
  required DOMString value;
};
      </pre>
      <div class="issue" data-number="119" title="Should negative amounts be reflected using signed values?">  
      The resolution of the WG per <a href="https://github.com/w3c/webpayments/issues/57"> Issue #57</a> defined  
      a format for currencies and amounts that lacked support for negative values. The format below adds this  
      capability in a way that is not common for financial messaging standards (using signed numbers). The
      rationale for negative numbers is to support discounts. The group is still discussing whether functionality
      to support discounts might be implemented in a different manner (e.g., via a transaction type).
      </div>  
      <p>
        A <a><code>CurrencyAmount</code></a> dictionary is used to supply monetary amounts.
        The following fields MUST be supplied for a <a><code>CurrencyAmount</code></a> to be valid:
      </p>
      <dl>
        <dt><code><dfn>currency</dfn></code></dt>
        <dd>
          <code>currency</code> is a string containing a currency identifier. The most common
          identifiers are three-letter alphabetic codes as defined by [[!ISO4217]] (for example,
          <code>"USD"</code> for US Dollars) however any string is considered valid and
          <a data-lt="user agents">user agents</a> MUST not attempt to validate this string.
        </dd>
        <dt><code><dfn>value</dfn></code></dt>
        <dd>
          A string containing the decimal monetary value. If a decimal separator is needed then the string
          MUST use a single U+002E FULL STOP character as the decimal separator. The string MUST begin  
          with a single U+002D HYPHEN-MINUS character if the value is negative. All other characters must  
          be characters in the range U+0030 DIGIT ZERO (0) to U+0039 DIGIT NINE (9).
          <div class="note">
            The string should match the regular expression <code>^-?[0-9]+(\.[0-9]+)?$</code>.
          </div>
        </dd>
      </dl>

      <p>The following example shows how to represent US$55.00.</p>
      <pre class="example highlight">
{
  "currency": "USD",
  "value" : "55.00"
}
      </pre>
    </section>

    <section>
      <h2>PaymentDetails dictionary</h2>
      <pre class="idl">
dictionary PaymentDetails {
  sequence&lt;PaymentItem&gt; items;
  sequence&lt;ShippingOption&gt; shippingOptions;
};
      </pre>

      <p>
        The <code><dfn>PaymentDetails</dfn></code> dictionary is passed to the <a><code>PaymentRequest</code></a>
        constructor and provides information about the requested transaction. The <code>PaymentDetails</code>
        dictionary is also used to update the payment request using <a><code>updateWith</code></a>.
      </p>
      <p>
        The following fields are part of the <code>PaymentDetails</code> dictionary:
      </p>
      <dl>
        <dt><code>items</code></dt>
        <dd>
          This sequence of <a><code>PaymentItem</code></a> dictionaries indicates what the payment
          request is for. The sequence must contain at least one <code>PaymentItem</code>. The last
          <code>PaymentItem</code> in the sequence represents the total amount of the payment
          request. It is the responsibility of the calling code to ensure that the total amount is
          the sum of the preceding items. The <a>user agent</a> MAY not validate that this is true.
        </dd>
        <dt><code>shippingOptions</code></dt>
        <dd>
          A sequence containing the different shipping options that the use may choose from.
          <p>If the sequence is empty, then this indicates that the merchant
          cannot ship to the current <a><code>shippingAddress</code></a>.</p>
          <p>If the sequence only contains one item, then this is the shipping option that
          will be used and <a><code>shippingOption</code></a> will be set to the <code>id</code>
          of this option without running the <a>shipping option changed algorithm</a>.</p>
        </dd>
      </dl>

      <div class="issue" data-number="18" title="Constructor should not include &quot;total&quot; in list of items">
        There is an open issue about whether the <code>items</code> sequence should special-case the last
        item in the sequence to represent the total.
      </div>
    </section>

    <section>
      <h2>PaymentOptions dictionary</h2>
      <pre class="idl">
dictionary PaymentOptions {
  boolean requestShipping = false;
};
      </pre>

      <p>
        The <code><dfn>PaymentOptions</dfn></code> dictionary is passed to the <a><code>PaymentRequest</code></a>
        constructor and provides information about the options desired for the payment request.
      </p>
      <p>
        The following fields MAY be passed to the <a><code>PaymentRequest</code></a> constructor:
      </p>
      <dl>
        <dt><code><dfn>requestShipping</dfn></code></dt>
        <dd>
          This <em>boolean</em> value indicates whether the <a>user agent</a> should collect and return
          a shipping address as part of the payment request. For example, this would be set to
          <code>true</code> when physical goods need to be shipped by the merchant to the user.
          This would be set to <code>false</code> for an online-only electronic purchase transaction.
          If this value is not supplied then the the <a><code>PaymentRequest</code></a> behaves as
          if a value of <code>false</code> had been supplied.
        </dd>
      </dl>
    </section>

    <section>
      <h2>PaymentItem dictionary</h2>
      <pre class="idl">
        dictionary PaymentItem {
          required DOMString id;
          required DOMString label;
          required CurrencyAmount amount;
        };
      </pre>
      <p>
        A sequence of one or more <code>PaymentItem</code> dictionaries is included in the <a><code>PaymentDetails</code></a>
        dictionary to indicate the what the payment request is for and the value asked for.
      </p>
      <p>
        The following fields MUST be included in a <code>PaymentItem</code> for it to be valid:
      </p>
      <dl>
        <dt><code>id</code></dt>
        <dd>This is a string identifier used to reference this <code>PaymentItem</code>. It MUST be
        unique for a given <a><code>PaymentRequest</code></a>.</dd>
        <dt><code>label</code></dt>
        <dd>This is a human-readable description of the item. The <a>user agent</a> may display
        this to the user.</dd>
        <dt><code>amount</code></dt>
        <dd>
          A <a><code>CurrencyAmount</code></a> containing the monetary amount for the item.
          <div class="issue" data-number="3" title="Should it be possible to provide amounts in more than one currency">
            There is an open issue about whether it should be possible to provide a <code>PaymentItem</code>
            with amounts in more than once currency.
          </div>
          <div class="issue" data-number="4" title="Should it be possible to vary amounts depending on payment method">
            There is an open issue about whether it should be possible to provide a different amounts depending
            upon the payment method.
          </div>
          <div class="issue" data-number="14" title="Handling non-decimal currencies">
            There is an open issue about whether and how to handle
            <a href="https://en.wikipedia.org/wiki/Non-decimal_currency">non-decimal currencies</a>.
          </div>
        </dd>
      </dl>
    </section>

    <section>
      <h2>ShippingAddress interface</h2>
      <pre class="idl">
        interface ShippingAddress {
          /* [...] fields TBC */
        };
      </pre>
      <p>
        If the <a>requestShipping</a> flag was set to <code>true</code> in the <a>PaymentOptions</a>
        passed to the <a>PaymentRequest</a> constructor, then the <a>user agent</a> will populate the
        <code>shippingAddress</code> field of the <a><code>PaymentRequest</code></a> object with
        the user's selected shipping address.
      </p>
      <div class="issue" data-number="6" title="Write-up proposal for shipping address fields">
        The fields of the <a><code>ShippingAddress</code></a> interface are
        yet to be defined.
      </div>
      <div class="issue" data-number="1" title="Should the merchant be able to request your email and recipient phone number">
        There is an open question about what data beyond shipping address the merchant might be able
        to request from the <a>user agent</a>. Is capturing email and recipient phone important to you?
      </div>
    </section>

    <section>
      <h2>ShippingOption interface</h2>
      <pre class="idl">
        dictionary ShippingOption {
          required string id;
          required string label;
          required CurrencyAmount amount;
        };
      </pre>
      <p>
        The <a>ShippingOption</a> dictionary has fields describing a shipping option. A web page can
        provide the user with one or more shipping options by calling the <a>updateWith</a>
        method in response to a change event.
      </p>
      <p>
        The following fields MUST be included in a <code>PaymentItem</code> for it to be valid:
      </p>
      <dl>
        <dt><code>id</code></dt>
        <dd>This is a string identifier used to reference this <code>ShippingOption</code>. It MUST be
        unique for a given <a><code>PaymentRequest</code></a>.</dd>
        <dt><code>label</code></dt>
        <dd>This is a human-readable description of the item. The <a>user agent</a> SHOULD use this
        string to display the shipping option to the user.</dd>
        <dt><code>amount</code></dt>
        <dd>
          A <a><code>CurrencyAmount</code></a> containing the monetary amount for the item.
        </dd>
      </dl>
    </section>

    <section>
      <h2>PaymentResponse interface</h2>
      <pre class="idl">
        interface PaymentResponse {
          readonly attribute DOMString methodName;
          readonly attribute object details;

          Promise&lt;void&gt; complete(boolean success);
        };
      </pre>

      <p>
        A <code><dfn>PaymentResponse</dfn></code> is returned when a user has selected a payment method and
        approved a payment request. It contains the following fields:
      </p>
      <dl>
      <dt><code><dfn>methodName</dfn></code></dt>
      <dd>
        The <a>payment method identifier</a> for the <a>payment method</a> that the user selected
        to fulfil the transaction.
      </dd>
      <dt><code><dfn>details</dfn></code></dt>
      <dd>
        A <a>JSON-serializable object</a> that provides a <a>payment method</a> specific message used by the merchant to
        process the transaction and determine successful fund transfer.
      </dd>
      </dl>

      <section>
        <h2>complete()</h2>
        <p>The <code><dfn>complete</dfn></code> method must be called after the user has accepted the payment
        request and the [[\acceptPromise]] has been resolved. The <code>complete</code> method
        takes a boolean argument that indicates the payment was successfully processed if <code>true</code> and
        that processing failed if <code>false</code>. Calling the <code>complete</code> method tells the user
        agent that the user interaction is over (and should cause any remaining user interface to be closed).</p>

        <div class="issue" data-number="17" title="complete() should take a string argument not boolean">
          There is an open issue about what values can be supplied to complete. These may depend on the
          payment method selected and should then be defined in Payment Transaction Message specifications
          such as the Basic Card Payment document.
        </div>

        <p>The <a><code>complete</code></a> method MUST act as follows:</p>
        <ol>
          <li>Let <em>promise</em> be a new <a>Promise</a>.</li>
          <li>
            If the value of the internal slot [[\completeCalled]] is <em>true</em>, then <a>throw</a> an <a><code>InvalidStateError</code></a>.
          </li>
          <li>Set the value of the internal slot [[\completeCalled]] to <em>true</em>.</li>
          <li>Return <em>promise</em> and asynchronously perform the remaining steps.</li>
          <li>
            Pass the value of <code>success</code> to the <a>Payment App</a> that accepted the
            payment request.
          </li>
          <li>Close down any remaining user interface.</li>
          <li>Resolve <em>promise</em> with <code>undefined</code>.</li>
        </ol>

        <div class="issue" data-number="5" title="Should the web page be able to provide status information before calling complete()">
        There is an open issue about whether there should be a way for a merchant to keep the user
        informed about the progress of a transaction after the user approves the payment request.
        </div>
      </section>

      <section>
        <h2>Internal Slots</h2>
        <p>Instances of <a><code>PaymentResponse</code></a> are created with the internal slots in
        the following table:</p>
        <table>
          <tr><th>Internal Slot</th><th>Description (<em>non-normative</em>)</th></tr>
          <tr>
            <td>[[\completeCalled]]</td>
            <td>
              <em>true</em> if the <a><code>complete</code></a> method has been called and <em>false</em>
              otherwise.
            </td>
          </tr>
        </table>
      </section>

    </section>

    <section>
      <h2>Events</h2>

      <section class="informative">
        <h2>Summary</h2>

        <table>
          <tr><th>Event name</th><th>Interface</th><th>Dispatched when...</th></tr>
          <tr>
            <td><code>shippingaddresschange</code></td>
            <td><a>PaymentRequestUpdateEvent</a></td>
            <td>The user provides a new shipping address.</td>
          </tr>
          <tr>
            <td><code>shippingoptionchange</code></td>
            <td><a>PaymentRequestUpdateEvent</a></td>
            <td>The user chooses a new shipping option.</td>
          </tr>
        </table>
      </section>

      <section>
        <h2>PaymentRequestUpdateEvent</h2>
        <pre class="idl">
[Constructor(DOMString type, optional PaymentRequestUpdateEventInit eventInitDict)]
interface PaymentRequestUpdateEvent : Event {
  void updateWith(Promise&lt;PaymentDetails&gt; d);
};

dictionary PaymentRequestUpdateEventInit : EventInit {
};
        </pre>
        <p>The <a><code>PaymentRequestUpdateEvent</code></a> enables the web page to update
        the details of the payment request in response to a user interaction.</p>
        <p>If the web page wishes to update the payment request then it should call <a><code>updateWith</code></a>
        and provide a promise that will resolve with a <a><code>PaymentDetails</code></a>
        dictionary containing changed values that the <a>user agent</a> SHOULD present to the user.</p>
        <p>The PaymentRequestUpdateEvent constructor MUST set the internal slot [[\waitForUpdate]]
        to <em>false</em>.</p>
        <p>The <code><dfn>updateWith</dfn></code> method MUST act as follows:</p>
        <ol>
          <li>
            Let <em>target</em> be the <a><code>PaymentRequest</code></a> object that is the target of
            the event.
          </li>
          <li>If the <a>dispatch flag</a> is unset, then <a>throw</a> an <a><code>InvalidStateError</code></a>.</li>
          <li>
            If [[\waitForUpdate]] is <em>true</em>, then <a>throw</a> an <a><code>InvalidStateError</code></a>.
          </li>
          <li>
            If <em>target</em>@[[\state]] is not <em>interactive</em>, then <a>throw</a> an
            <a><code>InvalidStateError</code></a>.
          </li>
          <li>
            If <em>target</em>@[[\updating]] is <em>true</em>, then <a>throw</a>
            an <a><code>InvalidStateError</code></a>.
          </li>
          <li>Set the <a>stop propagation flag</a> and <a>stop immediate propagation flag</a>.</li>
          <li>Set [[\waitForUpdate]] to <em>true</em>.</li>
          <li>Set <em>target</em>@[[\updating]] to <em>true</em>.</li>
          <li>
            The <a>user agent</a> SHOULD disable the user interface that allows the user to accept
            the payment request. This is to ensure that the payment is not accepted until the web page
            has made changes required by the change. The web page MUST settle the promise <code>d</code>
            to indicate that the payment request is valid again.
            <p>The <a>user agent</a> SHOULD disable any part of the user interface that could cause
            another update event to be fired. Only one update may be processed at a time.</p>
            <div class="issue" title="Consider adding a timeout to the updating flag in case page doesn't resolve promise from updateWith">
              We should consider adding a timeout mechanism so that if the page never resolves
              the promise within a reasonable amount of time then the user agent behaves as if
              the promise was rejected.
            </div>
          </li>
          <li>Return from the method and asynchronously perform the remaining steps.</li>
          <li>Wait until <code>d</code> settles.</li>
          <li>If <code>d</code> is resolved with <code>details</code> and <code>details</code> is a
          <a><code>PaymentDetails</code></a> dictionary, then:
            <ol>
              <li>
                If <code>details</code> contains an <code>items</code> value, then copy
                this value to the <code>items</code> field of <em>target</em>@[[\details]].
              </li>
              <li>
                If <code>details</code> contains a <code>shippingOptions</code> sequence, then
                copy this value to the <code>shippingOptions</code> field of <em>target</em>@[[\details]].
              </li>
              <li>Let <em>newOption</em> be <em>null</em>.</li>
              <li>
                If <code>details</code> contains a <code>shippingOptions</code> sequence with a
                length of 1, then set <em>newOption</em> to the <code>id</code> of the only
                <a><code>ShippingOption</code></a> in the sequence.
              </li>
              <li>
                Set the value of <a><code>shippingOption</code></a> on <em>target</em> to
                <em>newOption</em>.
              </li>
            </ol>
          </li>
          <li>Set [[\waitForUpdate]] to <em>false</em>.</li>
          <li>Set <em>target</em>@[[\updating]] to <em>false</em>.</li>
          <li>
            The <a>user agent</a> should update the user interface based on any changed values
            in <em>target</em>. The user agent SHOULD re-enable user interface elements that might
            have been disabled in the steps above if appropriate.
          </li>
        </ol>

      </section>
    </section>

    <p class="issue" data-number="53" title="Add section on internationalization">
      The spec needs to clearly state how it will handle internationalization
      issues (such as selection order for language via explicit preferences,
      Accept-Language headers, etc.)
    </p>


    <p class="issue" data-number="55" title="Add section on security considerations">
      The spec should indicate how data might be passed securely through the API using
      mechanisms such as field level encryption and message signing. While these may not
      be standardised a reference to the payment method specifications would be appropriate
      as well as some examples of how those specifcations might implement secure messaging.
    </p>

    <section>
      <h2>Algorithms</h2>

      <p>When the internal slot [[\state]] of a <a><code>PaymentRequest</code></a> object is set to
      <em>interactive</em>, the <a>user agent</a> will trigger the following algorithms based
      on user interaction.</p>

      <section>
        <h2>Shipping address changed algorithm</h2>
        <p>
          The <dfn>shipping address changed algorithm</dfn> runs when the user provides a new shipping
          address. It MUST run the following steps:
        </p>
        <ol>
          <li>Let <em>request</em> be the <a><code>PaymentRequest</code></a> object that the user is
          interacting with.</li>
          <li>Let <em>name</em> be <code><dfn>shippingaddresschange</dfn></code>.</li>
          <li>
            Set the <a><code>shippingAddress</code></a> attribute on <em>request</em> to the
            shipping address provided by the user.
          </li>
          <li>
            Run the <a>PaymentRequest updated algorithm</a> with <em>request</em> and <em>name</em>.
          </li>
        </ol>
      </section>

      <section>
        <h2>Shipping option changed algorithm</h2>
        <p>
          The <dfn>shipping option changed algorithm</dfn> runs when the user chooses a new shipping
          option. It MUST run the following steps:
        </p>
        <ol>
          <li>Let <em>request</em> be the <a><code>PaymentRequest</code></a> object that the user is
          interacting with.</li>
          <li>Let <em>name</em> be <code><dfn>shippingoptionchange</dfn></code>.</li>
          <li>
            Set the <a><code>shippingOption</code></a> attribute on <em>request</em> to the
            <code>id</code> string of the <a><code>ShippingOption</code></a> provided by the user.
          </li>
          <li>
            Run the <a>PaymentRequest updated algorithm</a> with <em>request</em> and <em>name</em>.
          </li>
        </ol>
      </section>

      <section>
        <h2>PaymentRequest updated algorithm</h2>
        <p>
          The <dfn>PaymentRequest updated algorithm</dfn> is run by other algorithms above to fire
          an event to indicate that a user has made a change to a <a><code>PaymentRequest</code></a>
          called <em>request</em> with an event name of <em>name</em>.</p>
        <p>It MUST run the following steps:</p>
        <ol>
          <li>
            If the <em>request</em>@[[\updating]] is <em>true</em>, then terminate
            this algorithm and take no further action. Only one update may take place at a time. This
            should never occur.
          </li>
          <li>
            If the <em>request</em>@[[\state]] is not set to <em>interactive</em>,
            then terminate this algorithm and take no further action. The <a>user agent</a> user interface
            should ensure that this never occurs.
          </li>
          <li>Let <em>event</em> be a new <a><code>PaymentRequestUpdateEvent</code></a>.</li>
          <li>
            <a>Queue a task</a> to <a>fire an event</a> named <em>name</em> of type <em>event</em>
            at <em>request</em>.
          </li>
        </ol>
      </section>

      <section>
        <h2>User agent delegates payment request algorithm</h2>

        <p>
          The <a><code>PaymentRequest</code></a> interface allows a web page to call <code>abort</code>
          to tell the <a>user agent</a> to abort the payment request and to tear down any user interface that
          might be shown. For example, a web page may choose to do this the goods they are selling are
          only available for a limited amount of time. If the user does not accept the payment request
          within the allowed time period, then the request will be aborted.
        </p>

        <p>
          A <a>user agent</a> may not always be able to abort a request. For example, if the <a>user agent</a>
          has delegated responsibility for the request to another app. To support this situation,
          the <a>user agent</a> must run the <dfn>User agent delegates payment request algorithm</dfn>.
          The algorithm MUST run the following steps:
        </p>

        <ol>
          <li>
            Let <em>request</em> be the <a><code>PaymentRequest</code></a> object that the user is
            interacting with.
          </li>
          <li>
            If the <em>request</em>@[[\updating]] is <em>true</em>, then terminate this
            algorithm and take no further action. The <a>user agent</a> user interface should ensure
            that this never occurs.
          </li>
          <li>
            If the <em>request</em>@[[\state]] is not <em>interactive</em>, then terminate this
            algorithm and take no further action. The <a>user agent</a> user interface should ensure
            that this never occurs.
          </li>
          <li>
            Set <em>request</em>@[[\state]] to <em>delegated</em>.
          </li>
        </ol>

        <p class="issue" data-number="39" title="How are web-based payment apps supported?">
          The architecture document suggests that payment apps may take
          numerous forms, including as web-based apps. This specification
          should describe how the user-agent will pass the payment request
          data and the complete signal to a web-based payment app and also how
          it will receive the payment response from the payment app.
        </p>

        <div class="issue" data-number="7" title="Should we support a delegated state for PaymentRequest?">
          <p>We believe there are <a>user agent</a> configurations that can cause the UI to get into a state
          where cancellation by the web page during user interaction is difficult. Users should still
          be able to cancel the payment but script will not be able to. We need to investigate in more
          detail the consequences of this and whether it is really needed.</p>
          <p>If we specify <code>delegated</code> then it isn't necessary for all <a>user agents</a> to be
          able to move to this state but it would be necessary for all payment flows that wish to call
          <a><code>abort</code></a> to account for the situation where this may fail in the <code>delegated</code>
          state.</p>
        </div>

        <p class="issue" data-number="50" title="How are payment requests and responses passed between the browser and third-party native wallets?">
          This specification should describe how the user agent will pass the 
          payment request data and the complete signal to a native payment app 
          and also how it will receive the payment response from the payment app.
        </p>

      </section>

      <section>
        <h2>User accepts the payment request algorithm</h2>
        <p>
          The <dfn data-lt="user accepts the payment request">user accepts the payment request
          algorithm</dfn> runs when the user accepts the payment request and confirms that they want
          to pay. It MUST run the following steps:
        </p>
        <ol>
          <li>
            Let <em>request</em> be the <a><code>PaymentRequest</code></a> object that the user is
            interacting with.
          </li>
          <li>
            If the <em>request</em>@[[\updating]] is <em>true</em>, then terminate this
            algorithm and take no further action. The <a>user agent</a> user interface should ensure
            that this never occurs.
          </li>
          <li>
            If <em>request</em>@[[\state]] is not <em>interactive</em> and
            the not <code>delegated</code>, then terminate this algorithm and take no further action.
            The <a>user agent</a> user interface should ensure that this never occurs.
          </li>
          <li>
            If the <code>requestShipping</code> value of <em>request</em>@[[\options]]
            is <code>true</code>, then if the <code>shippingAddress</code> attribute of <em>request</em>
            is <code>null</code> or if the <code>shippingOption</code> attribute of <em>request</em>
            is <code>null</code>, then terminate this algorithm and take no further action. This should
            never occur.
          </li>
          <li>
            Let <em>response</em> be a new <a><code>PaymentResponse</code></a>.
          </li>
          <li>
            Set the <code>methodName</code> attribute value of <em>response</em> to the <a>payment method identifier</a>
            for the <a>payment method</a> that the user selected to accept the payment.
          </li>
          <li>
            Set the <code>details</code> attribute value of <em>response</em> to a <a>JSON-serializable object</a>
            containing the <a>payment method</a> specific message used by the merchant to process
            the transaction. The format of this response will be defined by a <a>Payment Transaction
            Message Specification</a>.
          </li>
          <li>
            Set <em>response</em>@[[\completeCalled]] to <em>false</em>.
          </li>
          <li>
            Set <em>request</em>@[[\state]] to <em>closed</em>.
          </li>
          <li>
            Resolve the pending promise <em>request</em>@[[\acceptPromise]].
          </li>
        </ol>
      </section>
    </section>

    <div class="issue" data-number="20" title="Ensure references are up-to-date">
      The references in the spec need to be up-to-date.
    </div>

  </body>
</html>
